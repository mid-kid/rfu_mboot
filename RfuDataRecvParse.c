#if 1
__asm__("
.section .text
.global RfuDataRecvParse
.type RfuDataRecvParse, function
.thumb_func
RfuDataRecvParse:
.2byte 0xb5f0,0x464f,0x4646,0xb4c0,0xb082,0x4688,0x0412,0x0c13,0x4a06,0x7810,0x43c0,0x2101,0x4008,0x0100,0x4904,0x1846,0x7830,0x4691,0x4283,0xd205,0x1c18,0xe09a,0x60c0,0x0300,0x5648,0x0300,0x2700,0x2400,0x7875,0x79f3,0x9900,0x468c,0x4284,0xd20c,0x1c02,0x4641,0x7808,0x00e1,0x4088,0x4307,0x2001,0x4480,0x1c60,0x0400,0x0c04,0x4294,0xd3f3,0x1c38,0x40e8,0x4018,0x4d30,0x1c2b,0x4661,0x400b,0x4303,0x9300,0x1c38,0x78b1,0x40c8,0x7a31,0x4008,0x0200,0x4c2b,0x1c22,0x401a,0x4302,0x9200,0x1c38,0x78f1,0x40c8,0x7a71,0x4008,0x0400,0x4b27,0x4013,0x4303,0x9300,0x1c38,0x7931,0x40c8,0x7ab1,0x4008,0x0600,0x4923,0x468c,0x4019,0x4301,0x468c,0x9100,0x1c38,0x7971,0x40c8,0x7af1,0x4008,0x9a01,0x402a,0x4302,0x9201,0x1c38,0x79b1,0x40c8,0x7b31,0x4008,0x0200,0x4014,0x4304,0x9401,0x89f0,0x4007,0x0439,0x4816,0x4020,0x4308,0x9001,0x0c00,0x7836,0x1980,0x0400,0x0c07,0x4668,0x7800,0x2800,0xd134,0x4649,0x7888,0x4661,0x0a0d,0x4005,0x2d00,0xd02d,0x2400,0x2601,0x1c28,0x4120,0x4030,0x2800,0xd021,0x9800,0x0e00,0x2800,0xd110,0x0620,0x0e00,0x4669,0x4642,0xf000,0xf919,0xe016,0xff00,0xffff,0x00ff,0xffff,0xffff,0xff00,0xffff,0x00ff,0xffff,0x0000,0x480c,0x7900,0x4120,0x4030,0x2800,0xd006,0x0621,0x0e09,0x1c08,0x466a,0x4643,0xf000,0xf80f,0x1c60,0x0400,0x0c04,0x2c03,0xd9d3,0x1c38,0xb002,0xbc18,0x4698,0x46a1,0xbcf0,0xbc02,0x4708,0x60c0,0x0300
.size RfuDataRecvParse, .-RfuDataRecvParse
");
#else

#include <Agb.h>

#include "Mboot.h"
extern void FUN_03003b60(u8 param_1, u8 *param_2, u8 *param_3);
extern void FUN_0300397c(u8 param_1, u8 param_2, u8 *param_3);
extern struct Mboot Mboot;
extern u8 RfuEncTable[2][16];

u16 RfuDataRecvParse(u32 unused, u8 *Srcp, u16 Size)
{
    u16 x;
    u8 *enc;
    u32 bits;
    u32 fields[2];
    u16 ret;
    u8 mode;

    mode = ~Mboot.mode & 1;
    enc = RfuEncTable[mode];
    if (Size < enc[0]) return Size;

    bits = 0;
    for (x = 0; x < enc[0]; x++) {
        bits |= *Srcp++ << x * 8;
    }

    enc = RfuEncTable[mode];
    fields[0] = (bits >> enc[1] & enc[7]) << 0 | (fields[0] & 0xFFFFFF00);
    fields[0] = (bits >> enc[2] & enc[8]) << 8 | (fields[0] & 0xFFFF00FF);
    fields[0] = (bits >> enc[3] & enc[9]) << 16 | (fields[0] & 0xFF00FFFF);
    fields[0] = (bits >> enc[4] & enc[10]) << 24 | (fields[0] & 0x00FFFFFF);
    fields[1] = (bits >> enc[5] & enc[11]) << 0 | (fields[1] & 0xFFFFFF00);
    fields[1] = (bits >> enc[6] & enc[12]) << 8 | (fields[1] & 0xFFFF00FF);
    fields[1] = (bits & *(u16 *)(enc + 14)) << 16 | (fields[1] & 0x0000FFFF);
    ret = fields[0] + enc[0];

    if (*(u8 *)fields == 0) {
        u32 temp = (fields[1] >> 8) & Mboot.peersConn;

        for (x = 0; x < 4; x++) {
            if (!(temp >> x & 1)) continue;
            if ((fields[0] >> 24) == 0) {
                FUN_03003b60(x, (u8 *)fields, Srcp);
            } else if (Mboot.unk_04 & (1 << x)) {
                FUN_0300397c(x, x, (u8 *)&fields);
            }
        }
    }

    return ret;

}
#endif
